daml 1.2

module Dwolla.Utils where

import DA.Text


type BankAccountType     = Text
type FundingSourceStatus = Text
type FundingSourceType   = Text
type ProcessingChannel   = Text
type CustomerStatus      = Text
type CustomerType        = Text
type MicroDepositsStatus = Text
type TransferStatus      = Text
type Balance             = Amount


checking    : Text = "checking"
savings     : Text = "savings"
verified    : Text = "verified"
unverified  : Text = "unverified"
bank        : Text = "bank"
balance     : Text = "balance"
ach         : Text = "ach"
wire        : Text = "wire"
suspended   : Text = "suspended"
retry       : Text = "retry"
document    : Text = "document"
personal    : Text = "personal"
business    : Text = "business"
receiveOnly : Text = "receive-only"
pending     : Text = "pending"
processed   : Text = "processed"
failed      : Text = "failed"
cancelled   : Text = "cancelled"


bankAccountTypes      = [checking, savings]
fundingSourceStatuses = [verified, unverified]
fundingSourceTypes    = [bank, balance]
processingChannels    = [ach, wire]
customerStatuses      = [unverified, suspended, retry, document, verified]
customerTypes         = [unverified, personal, business, receiveOnly]
microDepositStatuses  = [pending, processed, failed]
transferStatuses      = [processed, pending, cancelled, failed]


isValid (ys : [t]) (x : t) = elem x ys


validBankAccountType     = isValid bankAccountTypes
validfundingSourceStatus = isValid fundingSourceStatuses
validFundingSourceType   = isValid fundingSourceTypes
validProcessingChannel   = isValid processingChannels
validCustomerStatus      = isValid customerStatuses
validCustomerType        = isValid customerTypes
validMicroDepositStatus  = isValid microDepositStatuses
validTransferStatus      = isValid transferStatuses


validSsn: Text -> Bool
validSsn ssn =
  let parts = splitOn "-" ssn
  in if (Prelude.length parts) == 3
     then let partLen = [3, 2, 4]
              zipped = zip parts partLen
          in all (\(p,l) -> validSsnSet l p) zipped
     else False


validSsnSet: Int -> Text -> Bool
validSsnSet len set | DA.Text.length set == len =
  let optInt = parseInt set
  in case optInt of
    Some i -> i >= 0 && i < 10 ^ len
    None -> False
validSsnSet _ _ = False

validSsnSet4 = validSsnSet 4


validIp: Text -> Bool
validIp ip =
  let parts = splitOn "." ip
  in if (Prelude.length parts) == 4
  then all (\p -> validIpSet p) parts
  else False


validIpSet: Text -> Bool
validIpSet set =
  let optInt = parseInt set
  in case optInt of
    Some i -> i >= 0 && i <= 255
    None -> False


data Amount = Amount
  with
    value    : Text
    currency : Text
  deriving (Eq, Show)


data Failure = Failure
  with
    code        : Text
    description : Text
  deriving (Eq, Show)

emptyFailure = Failure with code = "", description = ""


data Clearing = Clearing
  with
    optSource : Optional Text
    optDestination : Optional Text
  deriving (Eq, Show)

emptyClearing = Clearing with optSource = None, optDestination = None


data AchDetail = AchDetail
  with
    addenda : [Text]
    traceId : Text
  deriving (Eq, Show)

emptyAchDetail = AchDetail with addenda = [], traceId = ""


data AchDetails = AchDetails
  with
    source      : AchDetail
    destination : AchDetail
  deriving (Eq, Show)

emptyAchDetails = AchDetails with source = emptyAchDetail, destination = emptyAchDetail


main = scenario do
  debug (validBankAccountType "checking")
  debug (validIp "192.168.1.1")
  return ()
